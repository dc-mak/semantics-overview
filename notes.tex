\usepackage{proof}
\usepackage{ebproof}
\usepackage{listings}

\title{Programming Language Semantics}
\subtitle{An overview of operational, denotational and axiomatic styles of semantics}
\date{11th November, 2019}
\author{Dhruv Makwana}
\institute{%
Ten Minute Tech Net\\%
Engineering, Goldman Sachs}

\graphicspath{{./graphics/}}

\mode<article>{\lecturenumber{1}}

\addtolength{\jot}{0.5\baselineskip}

% Denotations
\newcommand{\den}[2]{ \mathcal{#1} [\![ #2 ]\!] }%
\newcommand{\denA}[1]{ \den{A}{#1} }%
\newcommand{\denB}[1]{ \den{B}{#1} }%
\newcommand{\denC}[1]{ \den{C}{#1} }%

\begin{document}

\maketitle

\mode*  % ignore text outside frame in presentation mode

These notes aim to provide a very brief overview of three styles of formal
semantics used to describe and understand programming languages, by
defining the syntax and semantics of a small, imperative language called `IMP'.
They borrow heavily from~\citet{winskel1993formal} for the structure and
examples.

\section{Syntax of IMP}

\begin{frame}
    \mode<beamer>{\frametitle{Syntax of IMP}}
    \[\begin{array}{rcl}
        a & ::= & n
                \mid X
                \mid a_0 + a_1
                \mid a_0 - a_1
                \mid a_0 \times a_1 \\
                \\
        b & ::= & \mathbf{true}
                \mid \mathbf{false}
                \mid a_0 = a_1
                \mid a_0 \leq a_1
                \mid \neg b
                \mid b_0 \wedge b_1
                \mid b_0 \vee b_1 \\
                \\
        c & ::= & \mathbf{skip}
                \mid X := a
                \mid c_0; c_1
                \mid \mathbf{if}\ b\ \mathbf{then}\ c_0\ \mathbf{else}\ c_1 \\
                && \mathbf{while}\ b\ \mathbf{do}\ c
    \end{array} \]
    \pause
    \begin{enumerate}
        \item No functions (for simplicity's sake).
        \item All terms are "well-typed" by definition.
        \item In code: either tagged-unions or inheritance.
    \end{enumerate}
\end{frame}

\section{Operational Semantics of IMP}

\begin{frame}
  Operational semantics are an abstract, mathematical specification of an interpreter.
  \footnote{The style presented here is big-step semantics.}
\end{frame}

\begin{frame}[fragile]{Evaluation of Arithmetic Expressions}
    $\langle a, \sigma \rangle \rightarrow n$ specifies an \emph{evaluation function}, from
    a pair of an arithmetic expression $a$ and a state $\sigma$ to an integer $n$.\\
    \begin{overprint}
        \onslide<1-3>
        \begin{gather*}
            \infer{\langle n , \sigma \rangle \rightarrow n}{} \\
            \infer[\text{\small if } X \in \mathrm{dom}(\sigma)]{\langle X , \sigma \rangle \rightarrow \sigma(X)}{} \\
            \infer[n_\mathrm{sum} = n_0 + n_1]{\langle a_0 + a_1 , \sigma \rangle \rightarrow n_\mathrm{sum}}{\langle a_0 , \sigma \rangle \rightarrow n_0 \qquad \langle a_1 , \sigma \rangle \rightarrow n_1}
        \end{gather*}
        \begin{alertenv}
        \begin{itemize}
            \onslide<2-3>{\item This does \emph{not} specify an evaluation order.}
            \onslide<3>{\item Behaviour is \emph{undefined} if variable is not in state.}
        \end{itemize}
        \end{alertenv}
        \onslide<4-5>
        \begin{lstlisting}[language=java, basicstyle=\small]
class AddExpr extends ArithExpr {
  private final ArithExpr left;
  private final ArithExpr right;
  @Override
  public int eval(Map<Var,Int> state) {
    return right.eval(state) + left.eval(state);
  }
}
        \end{lstlisting}
        \onslide<5>{Specification also allows left-first or parallel evaluation.}
    \end{overprint}
\end{frame}

\begin{frame}[fragile]{Evaluation of Boolean Expressions}
    $\langle b, \sigma \rangle \rightarrow v$ specifies an \emph{evaluation function}, from
    a pair of a boolean expression $b$ and a state $\sigma$ to an boolean $v$.\\
    \begin{overprint}
        \onslide<1-2>
        \begin{gather*}
            \infer{\langle b_0 \wedge b_1 , \sigma \rangle \rightarrow \mathbf{false}}{\langle b_0 , \sigma \rangle \rightarrow \mathbf{false}} \\
            \infer{\langle b_0 \wedge b_1 , \sigma \rangle \rightarrow v}{\langle b_0 , \sigma \rangle \rightarrow \mathbf{true} \qquad \langle b_1 , \sigma \rangle \rightarrow v}
        \end{gather*}
        \onslide<2>{\alert{This \emph{forces} a left-to-right evaluation order.}}
        \onslide<3>
        \begin{lstlisting}[language=java, basicstyle=\small]
class AndExpr extends BoolExpr {
  private final BoolExpr left;
  private final BoolExpr right;
  @Override
  public bool eval(Map<Var,Int> state) {
    return left.eval(state) && right.eval(state);
  }
}
        \end{lstlisting}
    \end{overprint}
\end{frame}

\begin{frame}[fragile]{Evaluation of Commands}
    $\langle c, \sigma \rangle \rightarrow \sigma'$ specifies an \emph{evaluation function}, from
    a pair of a command $c$ and a state $\sigma$ to a state $\sigma'$.\\
    \begin{overprint}
        \onslide<1>
        \begin{gather*}
            \infer{\langle \mathbf{skip}, \sigma \rangle \rightarrow \sigma}{} \\
            \infer{\langle X := a , \sigma \rangle \rightarrow \sigma[n/X]}{\langle a , \sigma \rangle \rightarrow n} \\
            \infer{\langle c_0; c_1 , \sigma \rangle \rightarrow \sigma''}{\langle c_0 , \sigma \rangle \rightarrow  \sigma' \qquad \langle c_1 , \sigma' \rangle \rightarrow \sigma''}
        \end{gather*}
        \onslide<2>
        \begin{lstlisting}[language=java, basicstyle=\small]
class AssignCmd extends Command {
  private final Var var;
  private final ArithExpr arith;
  @Override
  public Map<Var,Int> eval(Map<Var,Int> state) {
    return state.put(var, arith.eval(state));
  }
}
        \end{lstlisting}
        \onslide<3>
        \begin{gather*}
            \infer{\langle \mathbf{if}\ b\ \mathbf{then}\ c_0\ \mathbf{else}\ c_1, \sigma \rangle \rightarrow \sigma'}{\langle b , \sigma \rangle \rightarrow  \mathbf{true} \qquad \langle c_0 , \sigma \rangle \rightarrow \sigma'} \\
            \infer{\langle \mathbf{if}\ b\ \mathbf{then}\ c_0\ \mathbf{else}\ c_1, \sigma \rangle \rightarrow \sigma'}{\langle b , \sigma \rangle \rightarrow  \mathbf{false} \qquad \langle c_1 , \sigma \rangle \rightarrow \sigma'} \\
            \infer{\langle \mathbf{while}\ b\ \mathbf{do}\ c, \sigma \rangle \rightarrow \sigma}{\langle b , \sigma \rangle \rightarrow  \mathbf{false} } \\
            \infer{\langle \mathbf{while}\ b\ \mathbf{do}\ c, \sigma \rangle \rightarrow \sigma''}{\langle b , \sigma \rangle \rightarrow  \mathbf{true} \quad \langle c , \sigma \rangle \rightarrow \sigma' \quad \langle \mathbf{while}\ b\ \mathbf{do}\ c, \sigma' \rangle \rightarrow \sigma''}
        \end{gather*}
    \end{overprint}
\end{frame}

\begin{frame}
    Let $w \equiv \mathbf{while}\ b\ \mathbf{do}\ c$.\\
    Let $c_0 \sim c_1$ iff $\forall \sigma, \sigma'.\ \langle c_0, \sigma
    \rangle \rightarrow \sigma' \Leftrightarrow \langle c_1, \sigma \rangle
    \rightarrow \sigma'$.
    \begin{theorem}
        $w \sim \mathbf{if}\ b\ \mathbf{then}\ \{c; w\}\ \mathbf{else}\ \mathbf{skip}$.
    \end{theorem}
\end{frame}

\section{Denotational Semantics}

\begin{frame}
    Denotational semantics defines the \emph{meaning} of programs in a
    \emph{syntax-independent} way, in terms of a well-understood area of
    mathematics (domain theory or category theory).\\~\\
    This allows us to reason about \emph{program equivalence} more generically,
    potentially across \emph{different programming languages}.
\end{frame}

\begin{frame}{Denotations of Arithmetic \& Boolean Expressions}
    $\denA{a}$ and $\denB{b}$ are \emph{functions} from a state, to a number and
    boolean respectively.
    \pause
    \[\begin{array}{rcl}
        \denA{n} & = & \lambda \sigma.\ n \\
        \denA{X} & = & \lambda \sigma.\ \sigma(X) \\
        \denA{a_0 + a_1} & = & \lambda \sigma.\ \denA{a_0}\sigma + \denA{a_1}\sigma \\
        \denB{b_0 \wedge b_1} & = &
            \lambda \sigma.\ \begin{array}[t]{ll}
                \mathrm{true} & \denB{b_0}\sigma = \mathrm{true} \text{ and } \denB{b_1}\sigma = \mathrm{true} \\
                \mathrm{false} & \text{ otherwise}
            \end{array}
    \end{array}\]
    \pause
    \alert{In the absence of side-effects in expressions, order of evaluation specified \emph{operationally} is irrelevant.}
\end{frame}

\begin{frame}{Denotations of Simple Commands}
    For simple commands, the denotations are straightforward functions from state to state.
    \[\begin{array}{rcl}
        \denC{\mathbf{skip}} & = & \lambda \sigma.\ \sigma \\
        \denC{X := a} & = & \lambda \sigma.\ \sigma[\denA{a}\sigma/X] \\
        \denC{c_0; c_1} & = & \denC{c_1} \circ \denC{c_0} \\
        \denC{\mathbf{if}\ b\ \mathbf{then}\ c_0\ \mathbf{else}\ c_1} & = &
            \lambda \sigma.\ \begin{array}[t]{ll}
                \denC{c_0}\sigma & \text{if } \denB{b}\sigma = \mathrm{true} \\
                \denC{c_1}\sigma & \text{otherwise}
            \end{array}
    \end{array}\]
\end{frame}

\begin{frame}{Problems with Denotation of While-loop}
    However, there are a few constraints for the denotation of while-loops.
    \pause
    \begin{itemize}[<+->]
        \item Must be \emph{compositional}: only the meaning of the parts
            determines the meaning of the whole.
        \item Cannot be \emph{arbitrarily} self-referential for the
            sake of mathematical consistency (viz.~ZFC \& Russel's paradox).
        \item Must be able to represent and propagate (non-)termination (viz.
            halting problem).
    \end{itemize}
\end{frame}

\begin{frame}{Domain Theory}
    \emph{Domain theory} provides both
    \pause
    \begin{itemize}[<+->]
        \item Least-upper-bounds (suprema) for constructing \emph{fixed-points} to represent recursion \emph{soundly}.
        \item \emph{Continuous functions} for preserving and propagating (non-)termination.
    \end{itemize}
\end{frame}

\begin{frame}{Denotation of While-loop}
    \[\denC{\mathbf{while}\ b\ \mathbf{do}\ c} = \mathrm{fix}(\Gamma) \]
    where
    \[\Gamma(\phi) = \lambda \sigma.\ \begin{array}[t]{ll}
            \sigma & \text{if } \denB{b}\sigma = \mathrm{false} \\
            \phi(\denC{c}\sigma) & \textrm{ otherwise }
    \end{array}\]
    and
    \[\mathrm{fix}(f) = \bigsqcup_{n \in \mathbb{N}}{f^n(\perp)}\]
\end{frame}

\begin{frame}{Equivalence of Operational and Denotational Semantics}
    Because we invented our operational rules `out of thin air', as
    manipulation of pure syntax, it helps to be able to justify those
    rules using well-known maths (especially the self-referential semantics of
    a while-loop).
    \begin{theorem}
        $\forall \sigma, \sigma'.\ \langle c, \sigma \rangle \rightarrow \sigma' \Leftrightarrow \denC{c}{\sigma} = \sigma'$
    \end{theorem}
\end{frame}

\section{Axiomatic Semantics}

\begin{frame}
    So far, we've been looking at proving properties about the execution and
    meanings of \emph{all} programs.\\~\\
    \pause
    But what if we want to understand a \emph{particular} program?
    \pause
    \[\begin{aligned}
            &S := 0; N := 0; \\
            &\mathbf{while}\ \neg (N = 101)\ \mathbf{do}\\
            &\quad\{ S := S + N; N := N + 1 \}
        \end{aligned}\]
        \pause
    How would we prove that this program, when it terminates, is such that
    the value of $S$ is $\sum_{m=1}^{100} m$?
\end{frame}

\begin{frame}
    \mode<beamer>{\frametitle{Syntax of IMP Assertions}}
    \[\begin{array}{rcl}
        a & ::= & n
                \mid X
                \mid i
                \mid a_0 + a_1
                \mid a_0 - a_1
                \mid a_0 \times a_1 \\
                \\
        A & ::= & \mathbf{true}
                \mid \mathbf{false}
                \mid a_0 = a_1
                \mid a_0 \leq a_1
                \mid \neg A
                \mid A_0 \wedge A_1 \\
             && A_0 \vee A_1
                \mid A_0 \Rightarrow A_1
                \mid \forall i.\ A
                \mid \exists i.\ A \\
    \end{array} \]
\end{frame}

\begin{frame}{Generating Assertions (1)}
    \begin{gather*}
        \infer{\{A\}\mathbf{skip}\{A\}}{} \\
        \infer{\{A\}c_0; c_1\{C\}}{\{A\}c_0\{B\} \quad \{B\}c_1\{C\}} \\
        \infer{\{A\}\mathbf{if}\ b\ \mathbf{then}\ c_0\ \mathbf{else}\ c_1\{B\}}{\{A \wedge b\}c_0\{B\} \quad \{A \wedge \neg b\}c_1\{B\}} \\
    \end{gather*}
\end{frame}

\begin{frame}{Generating Assertions (2)}
    \begin{gather*}
        \infer{\{B[a/X]\}X := a\{B\}}{} \\
        \infer{\{A\}\mathbf{while}\ b\ \mathbf{do}\ c\{A \wedge \neg b\}}{\{A \wedge b\}c\{A\}} \\
        \infer{\{A\}c\{B\}}{A \textrm{\small{ implies }} A' \quad \{A'\}c_0\{B'\} \quad B' \textrm{\small{ implies }} B} \\
    \end{gather*}
\end{frame}

\begin{frame}{Proving a program correct}
    \begin{theorem}
        The sum program is correct w.r.t~its specification: key step is loop invariant
        $S := \sum_{m=1}^{N-1}$.
    \end{theorem}
\end{frame}


\section{Conclusion}

\begin{frame}
    \begin{itemize}[<+->]
        \item Different ways of understanding languages and programs.
        \item Material presented here is circa 1970's at latest\cite{winskel1993formal}
            -- can handle realistic languages and proofs now.
        \item All programmers already have an intuitive understanding of these
            things -- but this gives more precision to our thoughts.
    \end{itemize}
\end{frame}

\begin{frame}<beamer>
  Thank you.
\end{frame}

\appendix%

\begin{frame}[allowframebreaks]
  \bibliographystyle{plainnat}
  \bibliography{references}
\end{frame}

\end{document}
